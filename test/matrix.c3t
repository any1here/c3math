module matrix @test;

Matrix3x3 mat1 = {{ -20,  -7, -17,   4,  15,  20,  10,   8, -16, }};
Matrix3x2 mat2 = {{  -6,  12,   6,  17,  -1,  5,                 }};
Matrix3x3 mat3 = {{  -2,  20,  -1,  -6, -18,  12, -11,  -4,   0, }};
Matrix2x3 mat4 = {{   8,  -8,   7, -11,  14,  15,                }};
Matrix3x3 mat5 = {{   4,   6,   1,   3,   2,   5,   8,   5,   9, }};
Matrix3x2 mat6 = {{  -6, -15, -12, -11, -14,  12,                }};

Matrix4x4 mat7 = {{ -10, 7, -9, -1, -6, -8, -17, -4, -12, -18, 19, 9, -15, 16, -2, 2 }};
Matrix4x4 mat8 = {{ -19, -6, 17, -1, -3, -9, 3, 6, 5, 1, 19, 4, -20, 18, 11, 13 }};

Matrix1x3 mat9  = {{ 6, -2, 1 }};
Matrix3x1 mat10 = {{ 4, -6, 3 }};

Matrix2x2 mat11 = {{ 1, 5, 3, -2 }};

import std::io;
macro @assert_print(mat1, mat2, $msg = "Not equal")
{
	io::printfn("actual:   %s", mat1);
	io::printfn("expected: %s", mat2);
	assert(mat1 == mat2, $msg);
}

fn void equality()
{
	assert(mat1 == mat1);
}
fn void unequality()
{
	assert(mat1 != mat3);
}
fn void addition()
{
	@assert_print(mat1 + mat3, (Matrix3x3){{ -22,  13, -18,  -2,  -3,  32,  -1,   4, -16 }});
}
fn void negation()
{
	@assert_print(-mat1, (Matrix3x3){{  20,   7,  17,  -4, -15, -20, -10,  -8,  16, }});
}
fn void subtraction()
{
	@assert_print(mat1 - mat3, (Matrix3x3){{ -18, -27, -16,  10,  33,   8,  21,  12, -16 }});
}
fn void scalar_mul()
{
	@assert_print(mat1 * 2, (Matrix3x3){{ -40, -14, -34,   8,  30,  40,  20,  16, -32, }});
}
fn void scalar_div()
{
	@assert_print(mat1 / 2, (Matrix3x3){{ -10,-3.5,-8.5,   2, 7.5,  10,   5,   4,  -8, }});
}
fn void vector_mul()
{
	@assert_print(mat1 * (double[<3>]){ 2, 3, 4 }, (double[<3>]){ -129, 133, -20 });
}
fn void list_mul()
{
	@assert_print(mat1 * (double[3]){ 2, 3, 4 }, (double[3]){ -129, 133, -20 });
}
fn void matrix_mul()
{
	@assert_print(mat4 * mat2, (Matrix2x2){{ 120, 199, 6, -50 }});
	@assert_print(mat6 * mat4, (Matrix3x3){{ 40, 79, -249, -8, 49, -420, -192, -216, 12 }});
	@assert_print(mat8 * mat7, (Matrix4x4){{ 144, 133, 197, 187, -30, 19, 415, -20, -331, -493, 202, -223, 3, -162, 97, 129 }});
	@assert_print(mat9 * mat10, (Matrix1x1){{ 39 }});
	@assert_print(mat10 * mat9, (Matrix3x3){{ 24, -36, 18, -8, 12, -6, 4, -6, 3 }});
}
fn void determinant()
{
	@assert_print(mat1.@determinant(), 8158);
}
fn void minor()
{
	@assert_print(mat1.@minor(1, 2), -90);
}
fn void cofactor()
{
	@assert_print(mat1.@cofactor(1, 2), 90);
}
fn void comatrix()
{
	@assert_print(mat1.@comatrix(), (Matrix3x3){{ -400, 264, -118, -248, 490, 90, 115, 332, -272 }});
}
fn void adjugate()
{
	@assert_print(mat11.adjugate(), (Matrix2x2){{ -2, -5, -3, 1 }});
	@assert_print(mat1.adjugate(), (Matrix3x3){{ -400, -248, 115, 264, 490, 332, -118, 90, -272 }});
}
fn void trace()
{
	@assert_print(mat1.trace(), -21);
}
fn void transpose()
{
	@assert_print(mat1.transposed(), (Matrix3x3){{ -20, 4, 10, -7, 15, 8, -17, 20, -16 }});
	@assert_print(mat4.transposed(), (Matrix3x2){{ 8, 7, 14, -8, -11, 15 }});
	@assert_print(mat6.transposed(), (Matrix2x3){{ -6, -11, -15, -14, -12, 12 }});
}
fn void row_slice()
{
	@assert_print(@row_slice(mat1, 0), (Matrix2x3){{ -7, -17, 15, 20, 8, -16 }});
	@assert_print(@row_slice(mat1, 1), (Matrix2x3){{ -20, -17, 4, 20, 10, -16 }});
	@assert_print(@row_slice(mat1, 2), (Matrix2x3){{ -20, -7, 4, 15, 10, 8 }});

	@assert_print(@row_slice(mat4, 0), (Matrix1x3){{  -8, -11,  15, }});
	@assert_print(@row_slice(mat4, 1), (Matrix1x3){{   8,   7,  14, }});
}
fn void col_slice()
{
	@assert_print(@col_slice(mat1, 0), (Matrix3x2){{   4,  15,  20,  10,   8, -16 }});
	@assert_print(@col_slice(mat1, 1), (Matrix3x2){{ -20,  -7, -17,  10,   8, -16 }});
	@assert_print(@col_slice(mat1, 2), (Matrix3x2){{ -20,  -7, -17,   4,  15,  20 }});

	@assert_print(@col_slice(mat4, 0), (Matrix2x2){{   7, -11,  14,  15, }});
	@assert_print(@col_slice(mat4, 1), (Matrix2x2){{   8,  -8,  14,  15, }});
	@assert_print(@col_slice(mat4, 2), (Matrix2x2){{   8,  -8,   7, -11, }});
}
fn void identity()
{
	@assert_print(@identity(1), (Matrix1x1){{ 1 }});
	@assert_print(@identity(2), (Matrix2x2){{ 1, 0, 0, 1 }});
	@assert_print(@identity(3), (Matrix3x3){{ 1, 0, 0, 0, 1, 0, 0, 0, 1 }});
}
fn void inverted()
{
	// round up source and result matrices to nearest 1000th to
	// mitigate floating point precision problems
	Matrix3x3 source = {
		((double[<9>])
		matrix::inverse(mat5)!!.val
		* 1000).round() / 1000};
	Matrix3x3 result = {
		((double[<9>])
		{ -1.0/7.0, -1.0, 4.0/7.0, 13.0/49.0, 4.0/7.0, -17.0/49.0, -1.0/49.0, 4.0/7.0, -10.0/49.0 }
		* 1000).round() / 1000};
	@assert_print(source, result);
}
